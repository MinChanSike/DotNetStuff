using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;

using More;

namespace More
{
    public class Method
    {
        public SosMethodDefinition definition;
        public String fullTypeName;
        public String methodName;
        public Method(SosMethodDefinition definition)
        {
            this.definition = definition;

            Int32 lastPeriodIndex = definition.fullMethodName.LastIndexOf('.');
            this.fullTypeName = definition.fullMethodName.Remove(lastPeriodIndex);
            this.methodName = definition.fullMethodName.Substring(lastPeriodIndex + 1);
        }
    }
    class MethodOrganizer
    {
        public readonly Dictionary<String, List<Method>> fullTypeNameToMethods;
        public MethodOrganizer()
        {
            this.fullTypeNameToMethods = new Dictionary<String, List<Method>>();
        }
        public void AddMethod(Method method)
        {
            List<Method> methods;
            if(!fullTypeNameToMethods.TryGetValue(method.fullTypeName, out methods))
            {
                methods = new List<Method>();
                fullTypeNameToMethods.Add(method.fullTypeName, methods);
            }
            methods.Add(method);
        }
    }
    class PluggableObject
    {
        public readonly String currentObjectName;
        public readonly String genericName;
        public Boolean found;
        public PluggableObject(String currentObjectName, String genericName)
        {
            this.currentObjectName = currentObjectName;
            this.genericName = genericName;            
        }
    }
    class ProgramOptions : CLParser
    {
        public readonly CLSwitch methods;
        public readonly CLSwitch types;
        public readonly CLSwitch xmlcomments;

        public readonly CLStringArgument extraUsings;
        public readonly CLStringArgument excludeTypes;
        
        public readonly CLStringArgument pluggableObjects;

        public ProgramOptions()
        {
            methods = new CLSwitch('m', "methods", "Generate classes that wrap remote methods");
            Add(methods);

            types = new CLSwitch('t', "types", "Generate classes that define types found in these remote methods");
            Add(types);

            xmlcomments = new CLSwitch('x', "xmlcomments", "Generate valid XML comments (commonly used to comply with fxcop)");
            Add(xmlcomments);

            pluggableObjects = new CLStringArgument('p', "pluggable", "Allow the client to pass in the object name to the given interfaces");
            Add(pluggableObjects);

            extraUsings = new CLStringArgument('u', "using", "Add extra namespace to the usings list");
            Add(extraUsings);

            excludeTypes = new CLStringArgument('e', "exclude", "When generating types, exclude these ones (you will want to exclude types when the client already has access to the types)");
            Add(excludeTypes);
        }

        public override void PrintUsageHeader()
        {
            Console.Error.WriteLine("NpcClientGenerator.exe [options] <host> <port>");
        }
    }
    class Program
    {
        public static String SplitName(String fullName, out String @namespace)
        {
            Int32 periodIndex = fullName.LastIndexOf('.');

            if (periodIndex < 0)
            {
                @namespace = "";
                return fullName;
            }

            @namespace = fullName.Remove(periodIndex);
            return fullName.Substring(periodIndex + 1);
        }
        static Int32 Main(string[] args)
        {
            Console.WriteLine("//");
            Console.WriteLine("// This file is autogenerated using the NpcClientGenerator.");
            Console.WriteLine("// To use the NpcClientGenerator, there must be an NpcServer running.");
            Console.WriteLine("// Once the server is running, you can run the  NpcClientGenerator to generate this file.");
            Console.WriteLine("//");
            Console.WriteLine("// This file was generated with the following command:");
            Console.Write("//     NpcClientGenerator.exe");
            for (int i = 0; i < args.Length; i++)
            {
                Console.Write(' ');
                Console.Write(args[i]);
            }
            Console.WriteLine();
            Console.WriteLine("//");

            //
            // Command line arguments
            //
            ProgramOptions options = new ProgramOptions();
            List<String> nonOptionArgs = options.Parse(args);

            if (nonOptionArgs.Count != 2)
            {
                return options.ErrorAndUsage("Expected {0} non-option arguments but got {1}", 2, nonOptionArgs.Count);
            }

            String host = nonOptionArgs[0];
            UInt16 port = UInt16.Parse(nonOptionArgs[1]);

            Boolean xmlComments = options.xmlcomments.set;

            HashSet<String> excludeTypeSet = null;
            String[] extraUsings = null;
            Dictionary<String, PluggableObject> pluggableObjects = null;

            if(options.excludeTypes.set)
            {
                excludeTypeSet = new HashSet<String>(options.excludeTypes.ArgValue.Split(new Char[] { ',' }, StringSplitOptions.RemoveEmptyEntries));
            }
            if (options.extraUsings.set)
            {
                extraUsings = options.extraUsings.ArgValue.Split(new Char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
            }
            if (options.pluggableObjects.set)
            {
                String[] pluggableObjectStrings = options.pluggableObjects.ArgValue.Split(new Char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                pluggableObjects = new Dictionary<String, PluggableObject>();
                for (int i = 0; i < pluggableObjectStrings.Length; i++)
                {
                    String pluggableObjectString = pluggableObjectStrings[i];
                    Int32 colonIndex = pluggableObjectString.IndexOf(":");
                    if (colonIndex < 0) throw new InvalidOperationException(String.Format(
                         "Pluggable Object '{0}' is missing a colon", pluggableObjectString));
                    String currentObjectName = pluggableObjectString.Remove(colonIndex);
                    pluggableObjects.Add(currentObjectName, new PluggableObject(currentObjectName,
                        pluggableObjectString.Substring(colonIndex + 1)));
                }
            }

            //
            // Connect to Npc service
            //
            EndPoint endPoint = EndPoints.EndPointFromIPOrHost(host, port);

            Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            socket.Connect(endPoint);            
            TextReader reader = new StreamReader(new NetworkStream(socket));

            //
            // Print file header info
            //
            Console.WriteLine("using System;");
            Console.WriteLine("using System.Net;");
            Console.WriteLine("using System.Net.Sockets;");
            Console.WriteLine();
            Console.WriteLine("using More;");
            Console.WriteLine();
            if (extraUsings != null)
            {
                for (int i = 0; i < extraUsings.Length; i++)
                {
                    Console.WriteLine("using {0};", extraUsings[i]);
                }
                Console.WriteLine();
            }

            String currentNamespace = null;

            if (options.types.set)
            {
                socket.Send(Encoding.ASCII.GetBytes("type\n"));

                while (true)
                {
                    String typeDefinitionLine = reader.ReadLine();
                    if (typeDefinitionLine == null) throw new InvalidOperationException("Server closed unexpectedly");
                    if (typeDefinitionLine.Length == 0) break; // empty line

                    Int32 spaceIndex = typeDefinitionLine.IndexOf(' ');
                    String typeFullName = typeDefinitionLine.Remove(spaceIndex);
                    String typeDefinition = typeDefinitionLine.Substring(spaceIndex + 1);

                    String typeNamespace;
                    String typeName = SplitName(typeFullName, out typeNamespace);

                    if (excludeTypeSet != null && excludeTypeSet.Contains(typeName)) continue;

                    if (!typeNamespace.Equals(currentNamespace))
                    {
                        if(!String.IsNullOrEmpty(currentNamespace)) Console.WriteLine("}");

                        if (!String.IsNullOrEmpty(typeNamespace))
                        {
                            Console.WriteLine("namespace {0}", typeNamespace);
                            Console.WriteLine("{");
                        }

                        currentNamespace = typeNamespace;
                    }

                    if (typeDefinition.StartsWith("Enum"))
                    {
                        SosEnumDefinition enumDefinition = SosTypes.ParseSosEnumTypeDefinition(typeDefinition, 4);
                        if (xmlComments)
                        {
                            Console.WriteLine("    /// <summary>The {0} enum</summary>", typeName);
                        }
                        Console.WriteLine("    public enum {0}", typeName);
                        Console.WriteLine("    {");
                        foreach(KeyValuePair<String,Int32> pair in enumDefinition.Values)
                        {
                            if (xmlComments)
                            {
                                Console.WriteLine("        /// <summary>The {0} enum value</summary>", pair.Key);
                            }
                            Console.WriteLine("        {0} = {1},", pair.Key, pair.Value);
                        }
                        Console.WriteLine("    }");
                    }
                    else
                    {
                        SosObjectDefinition objectDefinition = SosTypes.ParseSosObjectTypeDefinition(typeDefinition, 0);
                        if (xmlComments)
                        {
                            Console.WriteLine("    /// <summary>The {0} class</summary>", typeName);
                        }
                        Console.WriteLine("    public class {0}", typeName);
                        Console.WriteLine("    {");
                        foreach (KeyValuePair<String, String> pair in objectDefinition.fieldNamesToFieldTypes)
                        {
                            String fieldTypeName = pair.Value;
                            String fieldName = pair.Key;

                            if (fieldName.Equals("class") || fieldName.Equals("struct"))
                            {
                                fieldName = "@" + fieldName;
                            }

                            if (xmlComments)
                            {
                                Console.WriteLine("        /// <summary>The {0} class field</summary>", fieldName);
                            }
                            Console.WriteLine("        public {0} {1};", fieldTypeName, fieldName);
                        }

                        if (xmlComments)
                        {
                            Console.WriteLine("         /// <summary>The empty constructor</summary>");
                        }
                        Console.WriteLine("        public {0}()", typeName);
                        Console.WriteLine("        {");
                        Console.WriteLine("        }");


                        Console.WriteLine("    }");
                    }
                }
            }            

            if (options.methods.set)
            {
                MethodOrganizer methodOrganizer = new MethodOrganizer();

                // print 
                socket.Send(Encoding.ASCII.GetBytes("methods\n"));
                while (true)
                {
                    String methodDefinitionLine = reader.ReadLine();
                    if (methodDefinitionLine == null) throw new InvalidOperationException("Server closed unexpectedly");
                    if (methodDefinitionLine.Length <= 0) break; // empty line

                    SosMethodDefinition methodDefinition = SosTypes.ParseMethodDefinition(methodDefinitionLine, 0);
                    methodOrganizer.AddMethod(new Method(methodDefinition));
                }

                // print objects
                foreach (KeyValuePair<String, List<Method>> pair in methodOrganizer.fullTypeNameToMethods)
                {
                    String typeNamespace;
                    String typeName = SplitName(pair.Key, out typeNamespace);

                    //
                    // Check if it is pluggable
                    //
                    Boolean isPluggable;
                    if(pluggableObjects == null)
                    {
                        isPluggable = false;
                    }
                    else
                    {
                        PluggableObject pluggableObject;
                        if(pluggableObjects.TryGetValue(typeName, out pluggableObject))
                        {
                            isPluggable = true;
                            pluggableObject.found = true;
                            typeName = pluggableObject.genericName;
                        }
                        else
                        {
                            isPluggable = false;
                        }
                    }


                    if (!typeNamespace.Equals(currentNamespace))
                    {
                        if (!String.IsNullOrEmpty(currentNamespace)) Console.WriteLine("}");
                        if (!String.IsNullOrEmpty(typeNamespace))
                        {
                            Console.WriteLine("namespace {0}", typeNamespace);
                            Console.WriteLine("{");
                        }
                        currentNamespace = typeNamespace;
                    }
                    if (xmlComments)
                    {
                        Console.WriteLine("    /// <summary>The NpcClient wrapper for {0}</summary>", typeName);
                    }
                    Console.WriteLine("    public class {0} : INpcClient", typeName);
                    Console.WriteLine("    {");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The NpcClient interface to perform npc calls</summary>");
                    }
                    Console.WriteLine("        public INpcClientCaller npcClientCaller;");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The empty constructor</summary>");
                    }
                    Console.WriteLine("        public {0}(){{}}", typeName);
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The constructor with an NpcClient</summary>");
                    }
                    Console.WriteLine("        public {0}(INpcClientCaller npcClientCaller)", typeName);
                    Console.WriteLine("        {");
                    Console.WriteLine("            this.npcClientCaller = npcClientCaller;");
                    Console.WriteLine("        }");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The constructor with an endpoint</summary>");
                    }
                    Console.WriteLine("        public {0}(EndPoint endPoint, Boolean threadSafe)", typeName);
                    Console.WriteLine("        {");
                    Console.WriteLine("            this.npcClientCaller = new NpcClient(endPoint, threadSafe);");
                    Console.WriteLine("        }");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The constructor with a socket</summary>");
                    }
                    Console.WriteLine("        public {0}(Socket socket, Boolean threadSafe)", typeName);
                    Console.WriteLine("        {");
                    Console.WriteLine("            this.npcClientCaller = new NpcClient(socket, threadSafe);");
                    Console.WriteLine("        }");

                    List<Method> methodList = pair.Value;

                    //
                    // Print Method Definitions
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>SosMethodDefinitions</summary>", typeName);
                    }
                    Console.WriteLine("        public readonly SosMethodDefinition[] methodDefinitions = new SosMethodDefinition[] {");
                    for (int i = 0; i < methodList.Count; i++)
                    {
                        Method method = methodList[i];
                        Console.Write("            new SosMethodDefinition(\"{0}\",\"{1}\"",
                            method.methodName, method.definition.returnSosTypeName);

                        if(method.definition.parameters != null)
                        {
                            foreach (SosMethodDefinition.Parameter parameter in method.definition.parameters)
                            {
                                Console.Write(",\"{0}\",\"{1}\"", parameter.sosTypeName, parameter.name);
                            }
                        }

                        Console.WriteLine("),");
                    }
                    Console.WriteLine("        };");

                    if (xmlComments)
                    {
                        /// <param name="args"></param>
                        Console.WriteLine("        /// <summary>Retrieve remote object and enum types from server and verify they are correct</summary>", typeName);
                    }
                    Console.WriteLine("        public void UpdateAndVerifyEnumAndObjectTypes()");
                    Console.WriteLine("        {");
                    Console.WriteLine("            npcClientCaller.UpdateAndVerifyEnumAndObjectTypes();");
                    Console.WriteLine("        }");
                    if (xmlComments)
                    {
                        /// <param name="args"></param>
                        Console.WriteLine("        /// <summary>Verify that expected method definitions are the same</summary>", typeName);
                        Console.WriteLine("        /// <param name=\"forceMethodUpdateFromServer\">True if you would like to update method defintions from server whether or not they have been cached</param>", typeName);
                    }
                    Console.WriteLine("        public void VerifyMethodDefinitions(Boolean forceMethodUpdateFromServer)");
                    Console.WriteLine("        {");
                    Console.WriteLine("            npcClientCaller.VerifyMethodDefinitions(forceMethodUpdateFromServer, methodDefinitions);");
                    Console.WriteLine("        }");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>Dispose the class</summary>", typeName);
                    }
                    Console.WriteLine("        public void Dispose()");
                    Console.WriteLine("        {");
                    Console.WriteLine("            npcClientCaller.Dispose();");
                    Console.WriteLine("        }");


                    //
                    // Print Methods
                    //
                    for (int i = 0; i < methodList.Count; i++)
                    {
                        Method method = methodList[i];
                        Boolean returnTypeIsVoid = method.definition.returnSosTypeName.Equals("Void");

                        if (xmlComments)
                        {
                            Console.WriteLine("        /// <summary>The {0} method</summary>", method.methodName);
                            if (method.definition.parameters != null)
                            {
                                foreach (SosMethodDefinition.Parameter parameter in method.definition.parameters)
                                {
                                    Console.WriteLine("        /// <param name=\"{0}\">The {0} parameter of type {1}</param>", parameter.name, parameter.sosTypeName);
                                }
                            }
                            if (!returnTypeIsVoid)
                            {
                                Console.WriteLine("        /// <returns>Return type is {0}</returns>", method.definition.returnSosTypeName);
                            }
                        }

                        Console.Write("        public {0} {1}(", returnTypeIsVoid ? "void" : method.definition.returnSosTypeName, method.methodName);

                        Boolean atFirstParameter = true;
                        if (isPluggable)
                        {
                            Console.Write("String objectName");
                            atFirstParameter = false;
                        }

                        if (method.definition.parameters != null)
                        {
                            foreach (SosMethodDefinition.Parameter parameter in method.definition.parameters)
                            {
                                if (atFirstParameter) atFirstParameter = false; else Console.Write(", ");

                                Console.Write(parameter.sosTypeName);
                                Console.Write(' ');
                                Console.Write(parameter.name);
                            }
                        }
                        Console.WriteLine(")");

                        Console.WriteLine("        {");


                        String methodString;
                        if (isPluggable)
                        {
                            methodString = String.Format("objectName + \".{0}\"", method.methodName);
                        }
                        else
                        {
                            methodString = "\"" + method.definition.fullMethodName + "\"";
                        }


                        if (returnTypeIsVoid)
                        {
                            Console.Write("            npcClientCaller.Call(typeof(void), {0}", methodString);
                        }
                        else
                        {
                            Console.Write("            return ({0})npcClientCaller.Call(typeof({0}), {1}",
                                method.definition.returnSosTypeName, methodString);
                        }

                        if (method.definition.parameters != null)
                        {
                            foreach (SosMethodDefinition.Parameter parameter in method.definition.parameters)
                            {
                                Console.Write(", ");
                                Console.Write(parameter.name);
                            }
                        }
                        Console.WriteLine(");");

                        Console.WriteLine("        }");
                    }

                    Console.WriteLine("    }");
                }
            }

            if(!String.IsNullOrEmpty(currentNamespace)) Console.WriteLine("}");

            if(options.methods.set && options.pluggableObjects.set)
            {
                StringBuilder builder = null;
                foreach (KeyValuePair<String, PluggableObject> pluggableObject in pluggableObjects)
                {
                    if (!pluggableObject.Value.found)
                    {
                        if (builder == null)
                        {
                            builder = new StringBuilder();
                        }
                        else
                        {
                            builder.Append(',');
                        }
                        builder.Append(pluggableObject.Key);
                    }
                }

                if (builder != null)
                {
                    throw new InvalidOperationException(String.Format(
                        "The service at '{0}' did not have the '{1}' object",
                        host, builder.ToString()));
                }
            }


            return 0;
        }
    }
}
