using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;

using More;

namespace More
{
    public class Method
    {
        public SosMethodDefinition definition;
        public String fullTypeName;
        public String methodName;
        public Method(SosMethodDefinition definition)
        {
            this.definition = definition;

            Int32 lastPeriodIndex = definition.fullMethodName.LastIndexOf('.');
            this.fullTypeName = definition.fullMethodName.Remove(lastPeriodIndex);
            this.methodName = definition.fullMethodName.Substring(lastPeriodIndex + 1);
        }
    }
    class MethodOrganizer
    {
        public readonly Dictionary<String, List<Method>> fullTypeNameToMethods;
        public MethodOrganizer()
        {
            this.fullTypeNameToMethods = new Dictionary<String, List<Method>>();
        }
        public void AddMethod(Method method)
        {
            List<Method> methods;
            if(!fullTypeNameToMethods.TryGetValue(method.fullTypeName, out methods))
            {
                methods = new List<Method>();
                fullTypeNameToMethods.Add(method.fullTypeName, methods);
            }
            methods.Add(method);
        }
    }
    class Program
    {
        static void Usage()
        {
            Console.Error.WriteLine("Usage: NpcClientGenerator.exe <host> <port> [--methods] [--types] [--xmlcomments] [--exlude TypeName,TypeName,...]");
            Console.Error.WriteLine("                              [--using Namespace,Namespace...]");
            Console.Error.WriteLine("   --methods               Generate classes that wraps remote methods");
            Console.Error.WriteLine("   --types                 Generate classes that define types found in these remote methods");
            Console.Error.WriteLine("   --xmlcomments           Generate valid XML comments (commonly used to comply with fxcop)");
            Console.Error.WriteLine("   --exclude Type,Type,... When generating types, exclude these ones (you will want to exclude types when the");
            Console.Error.WriteLine("                           client already has access to the types)");
            Console.Error.WriteLine("   --using Namespace,...   Add extra namespace to the usings list");
        }
        public static String SplitName(String fullName, out String @namespace)
        {
            Int32 periodIndex = fullName.LastIndexOf('.');

            if (periodIndex < 0)
            {
                @namespace = "";
                return fullName;
            }

            @namespace = fullName.Remove(periodIndex);
            return fullName.Substring(periodIndex + 1);
        }
        static Int32 Main(string[] args)
        {
            Console.WriteLine("//");
            Console.WriteLine("// This file is autogenerated using the NpcClientGenerator.");
            Console.WriteLine("// To use the NpcClientGenerator, there must be an NpcServer running.");
            Console.WriteLine("// Once the server is running, you can run the  NpcClientGenerator to generate this file.");
            Console.WriteLine("//");
            Console.WriteLine("// This file was generated with the following command:");
            Console.Write("//     NpcClientGenerator.exe");
            for (int i = 0; i < args.Length; i++)
            {
                Console.Write(' ');
                Console.Write(args[i]);
            }
            Console.WriteLine();
            Console.WriteLine("//");

            //
            // Parse command line arguments
            //
            if (args.Length < 3)
            {
                Console.WriteLine("Expected at least 3 arguments but got {0}", args.Length);
                Usage();
                return -1;
            }

            String host = args[0];
            UInt16 port = UInt16.Parse(args[1]);

            Boolean methods = false;
            Boolean types = false;
            Boolean xmlComments = false;
            HashSet<String> excludeTypeSet = null;
            String[] extraUsings = null;

            for (int i = 2; i < args.Length; i++)
            {
                String arg = args[i];
                if (arg.Equals("--methods", StringComparison.CurrentCultureIgnoreCase))
                {
                    methods = true;
                }
                else if (arg.Equals("--types", StringComparison.CurrentCultureIgnoreCase))
                {
                    types = true;
                }
                else if (arg.Equals("--xmlcomments", StringComparison.CurrentCultureIgnoreCase))
                {
                    xmlComments = true;
                }
                else if (arg.Equals("--exclude", StringComparison.CurrentCultureIgnoreCase))
                {
                    if (excludeTypeSet != null)
                        throw new InvalidOperationException("You've given the --exclude list more than once");

                    if (i >= args.Length)
                    {
                        Console.Error.WriteLine("Error: the '--exclude' option expected an comma seperated list of types after it");
                        return -1;
                    }
                    i++;
                    excludeTypeSet = new HashSet<String>(args[i].Split(new Char[]{','}, StringSplitOptions.RemoveEmptyEntries));
                }
                else if (arg.Equals("--using", StringComparison.CurrentCultureIgnoreCase))
                {
                    if (extraUsings != null)
                        throw new InvalidOperationException("You've given the --using option more than once");

                    if (i >= args.Length)
                    {
                        Console.Error.WriteLine("Error: the '--using' option expected an comma seperated list of namespaces after it");
                        return -1;
                    }
                    i++;
                    extraUsings = args[i].Split(new Char[] { ',' }, StringSplitOptions.RemoveEmptyEntries);
                }
                else
                {
                    Console.Error.WriteLine("Error: Unknown argument '{0}'", arg);
                    Usage();
                    return -1;
                }
            }

            //
            // Connect to Npc service
            //
            IPAddress hostIP;
            if (!IPAddress.TryParse(host, out hostIP))
            {
                IPAddress[] addresses = Dns.GetHostAddresses(host);
                if (addresses == null || addresses.Length <= 0)
                {
                    Console.WriteLine("Error: Could not resolve host \"{0}\" to an ip address", host);
                    return -1;
                }
                hostIP = addresses[0];
            }
            Socket socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
            socket.Connect(new IPEndPoint(hostIP, port));            
            TextReader reader = new StreamReader(new NetworkStream(socket));

            //
            // Print file header info
            //
            Console.WriteLine("using System;");
            Console.WriteLine("using System.Net;");
            Console.WriteLine("using System.Net.Sockets;");
            Console.WriteLine();
            Console.WriteLine("using More;");
            Console.WriteLine();
            if (extraUsings != null)
            {
                for (int i = 0; i < extraUsings.Length; i++)
                {
                    Console.WriteLine("using {0};", extraUsings[i]);
                }
                Console.WriteLine();
            }

            String currentNamespace = null;

            if (types)
            {
                socket.Send(Encoding.ASCII.GetBytes("type\n"));

                while (true)
                {
                    String typeDefinitionLine = reader.ReadLine();
                    if (typeDefinitionLine == null) throw new InvalidOperationException("Server closed unexpectedly");
                    if (typeDefinitionLine.Length == 0) break; // empty line

                    Int32 spaceIndex = typeDefinitionLine.IndexOf(' ');
                    String typeFullName = typeDefinitionLine.Remove(spaceIndex);
                    String typeDefinition = typeDefinitionLine.Substring(spaceIndex + 1);

                    String typeNamespace;
                    String typeName = SplitName(typeFullName, out typeNamespace);

                    if (excludeTypeSet != null && excludeTypeSet.Contains(typeName)) continue;

                    if (!typeNamespace.Equals(currentNamespace))
                    {
                        if(!String.IsNullOrEmpty(currentNamespace)) Console.WriteLine("}");

                        if (!String.IsNullOrEmpty(typeNamespace))
                        {
                            Console.WriteLine("namespace {0}", typeNamespace);
                            Console.WriteLine("{");
                        }

                        currentNamespace = typeNamespace;
                    }

                    if (typeDefinition.StartsWith("Enum"))
                    {
                        SosEnumDefinition enumDefinition = SosTypes.ParseSosEnumTypeDefinition(typeDefinition, 4);
                        if (xmlComments)
                        {
                            Console.WriteLine("    /// <summary>The {0} enum</summary>", typeName);
                        }
                        Console.WriteLine("    public enum {0}", typeName);
                        Console.WriteLine("    {");
                        foreach(KeyValuePair<String,Int32> pair in enumDefinition.Values)
                        {
                            if (xmlComments)
                            {
                                Console.WriteLine("        /// <summary>The {0} enum value</summary>", pair.Key);
                            }
                            Console.WriteLine("        {0} = {1},", pair.Key, pair.Value);
                        }
                        Console.WriteLine("    }");
                    }
                    else
                    {
                        SosObjectDefinition objectDefinition = SosTypes.ParseSosObjectTypeDefinition(typeDefinition, 0);
                        if (xmlComments)
                        {
                            Console.WriteLine("    /// <summary>The {0} class</summary>", typeName);
                        }
                        Console.WriteLine("    public class {0}", typeName);
                        Console.WriteLine("    {");
                        foreach (KeyValuePair<String, String> pair in objectDefinition.fieldNamesToFieldTypes)
                        {
                            String fieldTypeName = pair.Value;
                            String fieldName = pair.Key;

                            if (fieldName.Equals("class") || fieldName.Equals("struct"))
                            {
                                fieldName = "@" + fieldName;
                            }

                            if (xmlComments)
                            {
                                Console.WriteLine("        /// <summary>The {0} class field</summary>", fieldName);
                            }
                            Console.WriteLine("        public {0} {1};", fieldTypeName, fieldName);
                        }

                        if (xmlComments)
                        {
                            Console.WriteLine("         /// <summary>The empty constructor</summary>");
                        }
                        Console.WriteLine("        public {0}()", typeName);
                        Console.WriteLine("        {");
                        Console.WriteLine("        }");


                        Console.WriteLine("    }");
                    }
                }
            }            

            if (methods)
            {
                MethodOrganizer methodOrganizer = new MethodOrganizer();

                // print 
                socket.Send(Encoding.ASCII.GetBytes("methods\n"));
                while (true)
                {
                    String methodDefinitionLine = reader.ReadLine();
                    if (methodDefinitionLine == null) throw new InvalidOperationException("Server closed unexpectedly");
                    if (methodDefinitionLine.Length <= 0) break; // empty line

                    SosMethodDefinition methodDefinition = SosTypes.ParseMethodDefinition(methodDefinitionLine, 0);
                    methodOrganizer.AddMethod(new Method(methodDefinition));
                }

                // print objects
                foreach (KeyValuePair<String, List<Method>> pair in methodOrganizer.fullTypeNameToMethods)
                {
                    String typeNamespace;
                    String typeName = SplitName(pair.Key, out typeNamespace);
                    if (!typeNamespace.Equals(currentNamespace))
                    {
                        if (!String.IsNullOrEmpty(currentNamespace)) Console.WriteLine("}");
                        if (!String.IsNullOrEmpty(typeNamespace))
                        {
                            Console.WriteLine("namespace {0}", typeNamespace);
                            Console.WriteLine("{");
                        }
                        currentNamespace = typeNamespace;
                    }
                    if (xmlComments)
                    {
                        Console.WriteLine("    /// <summary>The NpcClient wrapper for {0}</summary>", typeName);
                    }
                    Console.WriteLine("    public class {0} : INpcClient", typeName);
                    Console.WriteLine("    {");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The NpcClient interface to perform npc calls</summary>");
                    }
                    Console.WriteLine("        public INpcClientCaller npcClientCaller;");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The empty constructor</summary>");
                    }
                    Console.WriteLine("        public {0}(){{}}", typeName);
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The constructor with an NpcClient</summary>");
                    }
                    Console.WriteLine("        public {0}(INpcClientCaller npcClientCaller)", typeName);
                    Console.WriteLine("        {");
                    Console.WriteLine("            this.npcClientCaller = npcClientCaller;");
                    Console.WriteLine("        }");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The constructor with an endpoint</summary>");
                    }
                    Console.WriteLine("        public {0}(EndPoint endPoint)", typeName);
                    Console.WriteLine("        {");
                    Console.WriteLine("            this.npcClientCaller = new NpcClient(endPoint);");
                    Console.WriteLine("        }");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>The constructor with a socket</summary>");
                    }
                    Console.WriteLine("        public {0}(Socket socket)", typeName);
                    Console.WriteLine("        {");
                    Console.WriteLine("            this.npcClientCaller = new NpcClient(socket);");
                    Console.WriteLine("        }");

                    List<Method> methodList = pair.Value;

                    //
                    // Print Method Definitions
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>SosMethodDefinitions</summary>", typeName);
                    }
                    Console.WriteLine("        public readonly SosMethodDefinition[] methodDefinitions = new SosMethodDefinition[] {");
                    for (int i = 0; i < methodList.Count; i++)
                    {
                        Method method = methodList[i];
                        Console.Write("            new SosMethodDefinition(\"{0}\",\"{1}\"",
                            method.methodName, method.definition.returnSosTypeName);

                        if(method.definition.parameters != null)
                        {
                            foreach (SosMethodDefinition.Parameter parameter in method.definition.parameters)
                            {
                                Console.Write(",\"{0}\",\"{1}\"", parameter.sosTypeName, parameter.name);
                            }
                        }

                        Console.WriteLine("),");
                    }
                    Console.WriteLine("        };");

                    if (xmlComments)
                    {
                        /// <param name="args"></param>
                        Console.WriteLine("        /// <summary>Retrieve remote object and enum types from server and verify they are correct</summary>", typeName);
                    }
                    Console.WriteLine("        public void UpdateAndVerifyEnumAndObjectTypes()");
                    Console.WriteLine("        {");
                    Console.WriteLine("            npcClientCaller.UpdateAndVerifyEnumAndObjectTypes();");
                    Console.WriteLine("        }");
                    if (xmlComments)
                    {
                        /// <param name="args"></param>
                        Console.WriteLine("        /// <summary>Verify that expected method definitions are the same</summary>", typeName);
                        Console.WriteLine("        /// <param name=\"forceMethodUpdateFromServer\">True if you would like to update method defintions from server whether or not they have been cached</param>", typeName);
                    }
                    Console.WriteLine("        public void VerifyMethodDefinitions(Boolean forceMethodUpdateFromServer)");
                    Console.WriteLine("        {");
                    Console.WriteLine("            npcClientCaller.VerifyMethodDefinitions(forceMethodUpdateFromServer, methodDefinitions);");
                    Console.WriteLine("        }");
                    if (xmlComments)
                    {
                        Console.WriteLine("        /// <summary>Dispose the class</summary>", typeName);
                    }
                    Console.WriteLine("        public void Dispose()");
                    Console.WriteLine("        {");
                    Console.WriteLine("            npcClientCaller.Dispose();");
                    Console.WriteLine("        }");


                    //
                    // Print Methods
                    //
                    for (int i = 0; i < methodList.Count; i++)
                    {
                        Method method = methodList[i];
                        Boolean returnTypeIsVoid = method.definition.returnSosTypeName.Equals("Void");

                        if (xmlComments)
                        {
                            Console.WriteLine("        /// <summary>The {0} method</summary>", method.methodName);
                            if (method.definition.parameters != null)
                            {
                                foreach (SosMethodDefinition.Parameter parameter in method.definition.parameters)
                                {
                                    Console.WriteLine("        /// <param name=\"{0}\">The {0} parameter of type {1}</param>", parameter.name, parameter.sosTypeName);
                                }
                            }
                            if (!returnTypeIsVoid)
                            {
                                Console.WriteLine("        /// <returns>Return type is {0}</returns>", method.definition.returnSosTypeName);
                            }
                        }

                        Console.Write("        public {0} {1}(", returnTypeIsVoid ? "void" : method.definition.returnSosTypeName, method.methodName);

                        if (method.definition.parameters != null)
                        {
                            Boolean atFirst = true;
                            foreach (SosMethodDefinition.Parameter parameter in method.definition.parameters)
                            {
                                if (atFirst) atFirst = false; else Console.Write(", ");

                                Console.Write(parameter.sosTypeName);
                                Console.Write(' ');
                                Console.Write(parameter.name);
                            }
                        }
                        Console.WriteLine(")");

                        Console.WriteLine("        {");


                        if (returnTypeIsVoid)
                        {
                            Console.Write("            npcClientCaller.Call(typeof(void), \"{0}\"", method.definition.fullMethodName);
                        }
                        else
                        {
                            Console.Write("            return ({0})npcClientCaller.Call(typeof({0}), \"{1}\"",
                                method.definition.returnSosTypeName, method.definition.fullMethodName);
                        }

                        if (method.definition.parameters != null)
                        {
                            foreach (SosMethodDefinition.Parameter parameter in method.definition.parameters)
                            {
                                Console.Write(", ");
                                Console.Write(parameter.name);
                            }
                        }
                        Console.WriteLine(");");

                        Console.WriteLine("        }");
                    }

                    Console.WriteLine("    }");
                }
            }

            if(!String.IsNullOrEmpty(currentNamespace)) Console.WriteLine("}");

            return 0;
        }
    }
}
