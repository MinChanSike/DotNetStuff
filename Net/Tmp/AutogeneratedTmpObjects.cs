// InputSha 0694535F6A589F9DAA6C2B3CD1EAF51886DDB6EB
//
// This file was autogenerated using the PdlCodeGenerator
//     GenerationDateTime : 7/23/2013 1:24:31 PM
//
using System;
using System.Text;

using More;

namespace More.Net.TmpCommand
{
    [Flags]
    public enum AccessorConnectionInfo {
        TmpRequiresTls = 1,
    }
    [Flags]
    public enum ServerConnectionInfo {
        IsTunnel = 1,
        RequireTls = 2,
    }
    [Flags]
    public enum TunnelOptions {
        RequireTls = 1,
    }
    public class ServerInfo
    {
        static InstanceSerializer serializer = null;
        public static IInstanceSerializer<ServerInfo> Serializer
        {
            get
            {
                if(serializer == null) serializer = new InstanceSerializer();
                return serializer;
            }
        }

        class InstanceSerializer : IInstanceSerializer<ServerInfo>
        {
            public InstanceSerializer() {}
            public UInt32 SerializationLength(ServerInfo instance)
            {
                UInt32 dynamicLengthPart = 0;
                if(instance.Name != null) dynamicLengthPart += (UInt32)instance.Name.Length * 1;
                return 5 + dynamicLengthPart;
            }
            public UInt32 Serialize(Byte[] bytes, UInt32 offset, ServerInfo instance)
            {
                UInt32 arrayLength;
                arrayLength = (instance.Name == null) ? 0 : (UInt32)instance.Name.Length;
                bytes[offset] = (Byte)(Byte)arrayLength;
                offset += 1;
                for(UInt32 i = 0; i < arrayLength; i++)
                {
                    bytes[offset] = instance.Name[i];
                    offset += 1;
                }
                bytes.BigEndianSetUInt16(offset, instance.SecondsPerHeartbeat);
                offset += 2;
                bytes.BigEndianSetUInt16(offset, instance.SecondsPerReconnect);
                offset += 2;
                return offset;
            }
            public UInt32 Deserialize(Byte[] bytes, UInt32 offset, UInt32 offsetLimit, out ServerInfo outInstance)
            {
                UInt32 arrayLength;
                ServerInfo instance = new ServerInfo();
                arrayLength = (Byte)bytes[offset];
                offset += 1;
                instance.Name = bytes.CreateSubArray(offset, arrayLength);
                offset += 1 * arrayLength;
                instance.SecondsPerHeartbeat = bytes.BigEndianReadUInt16(offset);
                offset += 2;
                instance.SecondsPerReconnect = bytes.BigEndianReadUInt16(offset);
                offset += 2;
                outInstance = instance;
                return offset;
            }
            public void DataString(ServerInfo instance, StringBuilder builder)
            {
                builder.Append("ServerInfo:{");
                // Arrays inside dynamic length objects not implemented
                builder.Append(',');
                builder.Append(instance.SecondsPerHeartbeat);
                builder.Append(',');
                builder.Append(instance.SecondsPerReconnect);
                builder.Append("}");
            }
            public void DataSmallString(ServerInfo instance, StringBuilder builder)
            {
                builder.Append("ServerInfo:{");
            // Arrays inside dynamic length objects not implemented
                builder.Append(',');
                builder.Append(instance.SecondsPerHeartbeat);
                builder.Append(',');
                builder.Append(instance.SecondsPerReconnect);
                builder.Append("}");
            }
        }

        public Byte[] Name;
        public UInt16 SecondsPerHeartbeat;
        public UInt16 SecondsPerReconnect;
        private ServerInfo() { }
        public ServerInfo(Byte[] Name, UInt16 SecondsPerHeartbeat, UInt16 SecondsPerReconnect)
        {
            this.Name = Name;
            this.SecondsPerHeartbeat = SecondsPerHeartbeat;
            this.SecondsPerReconnect = SecondsPerReconnect;
        }
        public InstanceSerializerAdapter<ServerInfo> CreateSerializerAdapater()
        {
            return new InstanceSerializerAdapter<ServerInfo>(Serializer, this);
        }
    }
    public class OpenAccessorTunnelRequest
    {
        static InstanceSerializer serializer = null;
        public static IInstanceSerializer<OpenAccessorTunnelRequest> Serializer
        {
            get
            {
                if(serializer == null) serializer = new InstanceSerializer();
                return serializer;
            }
        }

        class InstanceSerializer : IInstanceSerializer<OpenAccessorTunnelRequest>
        {
            public InstanceSerializer() {}
            public UInt32 SerializationLength(OpenAccessorTunnelRequest instance)
            {
                UInt32 dynamicLengthPart = 0;
                if(instance.TargetHost != null) dynamicLengthPart += (UInt32)instance.TargetHost.Length * 1;
                if(instance.TunnelKey != null) dynamicLengthPart += (UInt32)instance.TunnelKey.Length * 1;
                return 5 + dynamicLengthPart;
            }
            public UInt32 Serialize(Byte[] bytes, UInt32 offset, OpenAccessorTunnelRequest instance)
            {
                UInt32 arrayLength;
                ByteEnumSerializer<TunnelOptions>.Instance.FixedLengthSerialize(bytes, offset, instance.Options);
                offset += 1;
                arrayLength = (instance.TargetHost == null) ? 0 : (UInt32)instance.TargetHost.Length;
                bytes[offset] = (Byte)(Byte)arrayLength;
                offset += 1;
                for(UInt32 i = 0; i < arrayLength; i++)
                {
                    bytes[offset] = instance.TargetHost[i];
                    offset += 1;
                }
                bytes.BigEndianSetUInt16(offset, instance.TargetPort);
                offset += 2;
                arrayLength = (instance.TunnelKey == null) ? 0 : (UInt32)instance.TunnelKey.Length;
                bytes[offset] = (Byte)(Byte)arrayLength;
                offset += 1;
                for(UInt32 i = 0; i < arrayLength; i++)
                {
                    bytes[offset] = instance.TunnelKey[i];
                    offset += 1;
                }
                return offset;
            }
            public UInt32 Deserialize(Byte[] bytes, UInt32 offset, UInt32 offsetLimit, out OpenAccessorTunnelRequest outInstance)
            {
                UInt32 arrayLength;
                OpenAccessorTunnelRequest instance = new OpenAccessorTunnelRequest();
                instance.Options = ByteEnumSerializer<TunnelOptions>.Instance.FixedLengthDeserialize(bytes, offset);
                offset += 1;
                arrayLength = (Byte)bytes[offset];
                offset += 1;
                instance.TargetHost = bytes.CreateSubArray(offset, arrayLength);
                offset += 1 * arrayLength;
                instance.TargetPort = bytes.BigEndianReadUInt16(offset);
                offset += 2;
                arrayLength = (Byte)bytes[offset];
                offset += 1;
                instance.TunnelKey = bytes.CreateSubArray(offset, arrayLength);
                offset += 1 * arrayLength;
                outInstance = instance;
                return offset;
            }
            public void DataString(OpenAccessorTunnelRequest instance, StringBuilder builder)
            {
                builder.Append("OpenAccessorTunnelRequest:{");
                builder.Append(instance.Options);
                builder.Append(',');
                // Arrays inside dynamic length objects not implemented
                builder.Append(',');
                builder.Append(instance.TargetPort);
                builder.Append(',');
                // Arrays inside dynamic length objects not implemented
                builder.Append("}");
            }
            public void DataSmallString(OpenAccessorTunnelRequest instance, StringBuilder builder)
            {
                builder.Append("OpenAccessorTunnelRequest:{");
                builder.Append(instance.Options);
                builder.Append(',');
            // Arrays inside dynamic length objects not implemented
                builder.Append(',');
                builder.Append(instance.TargetPort);
                builder.Append(',');
            // Arrays inside dynamic length objects not implemented
                builder.Append("}");
            }
        }

        public TunnelOptions Options;
        public Byte[] TargetHost;
        public UInt16 TargetPort;
        public Byte[] TunnelKey;
        private OpenAccessorTunnelRequest() { }
        public OpenAccessorTunnelRequest(TunnelOptions Options, Byte[] TargetHost, UInt16 TargetPort, Byte[] TunnelKey)
        {
            this.Options = Options;
            this.TargetHost = TargetHost;
            this.TargetPort = TargetPort;
            this.TunnelKey = TunnelKey;
        }
        public InstanceSerializerAdapter<OpenAccessorTunnelRequest> CreateSerializerAdapater()
        {
            return new InstanceSerializerAdapter<OpenAccessorTunnelRequest>(Serializer, this);
        }
    }
    public class OpenTunnelRequest
    {
        static InstanceSerializer serializer = null;
        public static IInstanceSerializer<OpenTunnelRequest> Serializer
        {
            get
            {
                if(serializer == null) serializer = new InstanceSerializer();
                return serializer;
            }
        }

        class InstanceSerializer : IInstanceSerializer<OpenTunnelRequest>
        {
            public InstanceSerializer() {}
            public UInt32 SerializationLength(OpenTunnelRequest instance)
            {
                UInt32 dynamicLengthPart = 0;
                if(instance.TargetHost != null) dynamicLengthPart += (UInt32)instance.TargetHost.Length * 1;
                if(instance.OtherTargetHost != null) dynamicLengthPart += (UInt32)instance.OtherTargetHost.Length * 1;
                return 7 + dynamicLengthPart;
            }
            public UInt32 Serialize(Byte[] bytes, UInt32 offset, OpenTunnelRequest instance)
            {
                UInt32 arrayLength;
                ByteEnumSerializer<TunnelOptions>.Instance.FixedLengthSerialize(bytes, offset, instance.Options);
                offset += 1;
                arrayLength = (instance.TargetHost == null) ? 0 : (UInt32)instance.TargetHost.Length;
                bytes[offset] = (Byte)(Byte)arrayLength;
                offset += 1;
                for(UInt32 i = 0; i < arrayLength; i++)
                {
                    bytes[offset] = instance.TargetHost[i];
                    offset += 1;
                }
                bytes.BigEndianSetUInt16(offset, instance.TargetPort);
                offset += 2;
                arrayLength = (instance.OtherTargetHost == null) ? 0 : (UInt32)instance.OtherTargetHost.Length;
                bytes[offset] = (Byte)(Byte)arrayLength;
                offset += 1;
                for(UInt32 i = 0; i < arrayLength; i++)
                {
                    bytes[offset] = instance.OtherTargetHost[i];
                    offset += 1;
                }
                bytes.BigEndianSetUInt16(offset, instance.OtherTargetPort);
                offset += 2;
                return offset;
            }
            public UInt32 Deserialize(Byte[] bytes, UInt32 offset, UInt32 offsetLimit, out OpenTunnelRequest outInstance)
            {
                UInt32 arrayLength;
                OpenTunnelRequest instance = new OpenTunnelRequest();
                instance.Options = ByteEnumSerializer<TunnelOptions>.Instance.FixedLengthDeserialize(bytes, offset);
                offset += 1;
                arrayLength = (Byte)bytes[offset];
                offset += 1;
                instance.TargetHost = bytes.CreateSubArray(offset, arrayLength);
                offset += 1 * arrayLength;
                instance.TargetPort = bytes.BigEndianReadUInt16(offset);
                offset += 2;
                arrayLength = (Byte)bytes[offset];
                offset += 1;
                instance.OtherTargetHost = bytes.CreateSubArray(offset, arrayLength);
                offset += 1 * arrayLength;
                instance.OtherTargetPort = bytes.BigEndianReadUInt16(offset);
                offset += 2;
                outInstance = instance;
                return offset;
            }
            public void DataString(OpenTunnelRequest instance, StringBuilder builder)
            {
                builder.Append("OpenTunnelRequest:{");
                builder.Append(instance.Options);
                builder.Append(',');
                // Arrays inside dynamic length objects not implemented
                builder.Append(',');
                builder.Append(instance.TargetPort);
                builder.Append(',');
                // Arrays inside dynamic length objects not implemented
                builder.Append(',');
                builder.Append(instance.OtherTargetPort);
                builder.Append("}");
            }
            public void DataSmallString(OpenTunnelRequest instance, StringBuilder builder)
            {
                builder.Append("OpenTunnelRequest:{");
                builder.Append(instance.Options);
                builder.Append(',');
            // Arrays inside dynamic length objects not implemented
                builder.Append(',');
                builder.Append(instance.TargetPort);
                builder.Append(',');
            // Arrays inside dynamic length objects not implemented
                builder.Append(',');
                builder.Append(instance.OtherTargetPort);
                builder.Append("}");
            }
        }

        public TunnelOptions Options;
        public Byte[] TargetHost;
        public UInt16 TargetPort;
        public Byte[] OtherTargetHost;
        public UInt16 OtherTargetPort;
        private OpenTunnelRequest() { }
        public OpenTunnelRequest(TunnelOptions Options, Byte[] TargetHost, UInt16 TargetPort, Byte[] OtherTargetHost, UInt16 OtherTargetPort)
        {
            this.Options = Options;
            this.TargetHost = TargetHost;
            this.TargetPort = TargetPort;
            this.OtherTargetHost = OtherTargetHost;
            this.OtherTargetPort = OtherTargetPort;
        }
        public InstanceSerializerAdapter<OpenTunnelRequest> CreateSerializerAdapater()
        {
            return new InstanceSerializerAdapter<OpenTunnelRequest>(Serializer, this);
        }
    }
}
